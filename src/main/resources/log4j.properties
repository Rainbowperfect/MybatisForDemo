-公共服务
内容管理服务（ContentManagementService）
内容存储服务（ContentStorageService）
内容发布服务（ContentPublishService）
内容日志服务（ContentLogService）
格式转换服务（ConvertContextService）
公共组件Jar（CBBService）
邮件服务（MailService）
ID生成器服务（IDGenerateService）
元数据服务（MetaService）
内容定义服务（ContentDefinitionService）
系统配置服务（SysconfigService）
操作日志服务（OperationLogService）
国际化（I18nService）
权限服务（EntitlementService）
外系统集成：网关服务：IntegrationGwService、IDP集成服务：IdpService
DFX公共服务：DFX公共CBB服务（DfxCBBService）、导入导出服务（ImportExportService）、工作流服务（WorkflowService）
	

---公共领域服务
权限管理：栏目权限服务（CloumnService）、dfx权限申请服务（EntitlementApplyService）
网站消息服务：消息服务（NoticeMessageService）
站点统计：统计服务（StatisticService）
系统管理：模板管理服务（TemplateService）、能力库管理服务（AbilityRepoService）
全文搜索：
搜索定时任务服务：SearchTaskService
搜索索引服务：SearchIndexService
搜索爬虫服务：SearchCrawlerService
搜索数据处理服务：SearchDataProcessService
搜索查询服务：SearchQueryService


---Mq消息的可靠性--
会话是在客户机和消息发送系统之间的连接上一系列被发送和接收的消息。当创建会话时，它可以是非事务处理的（默认）也可以是事务处理的。事务处理会话保证一组消息
要么都被发送接收，要么都不被发送接收。非事务处理会话意味着消息被分别发送和接收。在线购物就是事务处理会话的一个实例。客户打开订单（开始事务处理）。客户选
择的每项商品都是一条在订单中添加商品的消息。客户关闭订单（结束事务处理）。如果发送器提交了事务处理，那么将发送组中所有的消息。如果发送器回退事务处理的话，那么将不订购任何商品项目
对于其他程序，低可靠性可以降低开销和提高性能，例如发送消息时可以更改消息的优先级或者指定消息的过期时间。
消息传送的可靠性越高,需要的开销和带宽就越多.性能和可靠性之间的折衷是设计时要重点考虑的一个方面。可以选择生成和使用非持久性消息来获得最佳性能。另一方面，也可以通过生成和使用持久性消息并使用事务会话来获得最佳可靠性。在这两种极端之间有许多选择，这取决于应用程序的要求。

-----MQ消息的指定出传送模式：(PERSISTENT和NON_persistent)
有两种方法指定传送模式：
1．使用setDeliveryMode方法，这样所有的消息都采用此传送模式；
2．使用send方法为每一条消息设置传送模式；
Java客户端：
传送模式分别为：
1．  DeliveryMode.PERSISTENT
2．  DeliveryMode.NON_PERSISTENT
ActiveMQMessageProducer方法： 
void setDeliveryMode(int newDeliveryMode);
或者
void send(Destination destination, Message message, int deliveryMode, int priority,
long timeToLive);
void send(Message message, int deliveryMode, int priority, long timeToLive);
其中deliveryMode为传送模式，priority为消息优先级，timeToLive为消息过期时间。
例如：
producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
消息优先级从0-9十个级别，0-4是普通消息，5-9是加急消息。如果不指定优先级，则默认为4。
默认情况下，消息永不会过期。如果消息在特定周期内失去意义，那么可以设置过期时间。
有两种方法设置消息的过期时间，时间单位为毫秒：
默认的activemq消息存储是通过一个所谓的AMQ Message Store来完成。AMQ Message Store是一个高效的可嵌入支持事务的消息存储解决方案。在此方案下消息（Message）本身以日志的形式实现持久化，存放在Data Log里。并且还对日志里的消息做了引用索引，方便快速取回Message。
一般情况下消息索引存放于内存（Cache）中，MQ Server定期将索引内容持久化，存放到Reference Store。Message Data Log文件是有容量限制的，默认是32MB，可自行配置容量。当该Data Log文件里所有消息都被消费完的时候，Data Log文件就会被加上一个标记，通知下一次消息清理时可以被处理掉（处理方式可以是delete或是转移到Achieve目录）。



---connection.createSession中的参数的解释
ActiveMQConnection方法：
Session createSession(boolean transacted, int acknowledgeMode);
例如：Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
对队列来说，如果当一个Session终止时它接收了消息但是没有签收，那么ActiveMQ将保留这些消息并将再次传送给下一个进入队列的消费者。
对主题来说，如果持久订阅用户终止时，它已消费未签收的消息也将被保留，直到再次传送给这个用户。对于非持久订阅，AtiveMQ在用户Session关闭时将删除这些消息。
如果使用队列和持久订阅，并且Session没有使用事务，那么可以使用Session的recover方法停止Session，再次启动后将收到它第一条没有签收的消息，事实上，重启后Session一系列消息的传送都是以上一次最后一条已签收消息的下一条为起点。如果这时有消息过期或者高优先级的消息到来，那么这时消息的传送将会和最初的有所不同。对于非持久订阅用户，重启后，ActiveMQ有可能删除所有没有签收的消息。

---package com.org.dfx.componentwebsite.component.controller;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStream;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.core.MediaType;

import com.org.dfx.cbb.upload.contentstoragement.ContentStorageBase;
import com.org.dfx.cbb.upload.contentstoragement.NasContentStorage;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.util.Base64Utils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;

import com.org.dfx.cbb.config.SysConfigUtil;
import com.org.dfx.cbb.util.excel.exception.ExcelException;
import com.org.dfx.cbb.web.entity.BaseResponseBody;
import com.org.dfx.cbb.web.entity.BaseResponseMsg;
import com.org.dfx.cbb.web.entity.ResponseHead;
import com.org.dfx.componentwebsite.component.constants.ComponentConstant;
import com.org.dfx.componentwebsite.component.constants.ComponentErrorCodeConstant;
import com.org.support.cbb.util.json.JSONUtil;
import com.org.support.cbb.util.partno.PartNoUtil;
import com.org.support.cbb.util.partno.PartNoUtil.PartNoType;
import com.org.support.cbb.util.security.CodeCCUtils;
import com.org.support.cbb.util.uuid.UUIDUtils;
import com.org.support.contentstorageservice.client.handler.exception.CSException;
import com.org.support.contentstorageservice.client.handler.facade.IContentStorage;
import com.org.support.contentstorageservice.client.handler.facade.NasContentStorageImpl;
import com.org.support.contentstorageservice.client.handler.service.image.NasCSImageServiceImpl;
import com.org.support.contentstorageservice.service.ContentStorageService;
import com.org.tools.commonlib.exception.ServiceException;

@Controller @RequestMapping("/upload") public class ComponentUploadController
{

    //日志记录
    public static final Logger LOG = LoggerFactory.getLogger(ComponentUploadController.class);

    @Autowired private ContentStorageService contentStorageService;

    ContentStorageBase contentStorage = new NasContentStorage();

    private IContentStorage ContentStorageImpl = new NasContentStorageImpl();

    private NasCSImageServiceImpl nasCSImageServiceImpl = new NasCSImageServiceImpl();

    /**
     * 上传图片
     * @param file
     * @return BaseResponseMsg
     * @throws Exception
     */
    @RequestMapping(value = "/uploadIcon", consumes = "multipart/form-data", produces = "application/json", method = RequestMethod.POST) public BaseResponseMsg uploadTempIcon(
        HttpServletRequest request, @RequestParam MultipartFile file)
        throws ExcelException
    {
        BaseResponseBody body = new BaseResponseBody();
        ResponseHead head = new ResponseHead();
        BaseResponseMsg msg = new BaseResponseMsg(head, body);
        if (null == file)
        {
            head.setErrorcode(ComponentErrorCodeConstant.FILE_IS_NULL);
            return msg;
        }
        Long maxSize = (long)2097151;
        if (file.getSize() > maxSize)
        {
            head.setErrorcode(ComponentErrorCodeConstant.ICON_OVERSIZE);
            return msg;
        }
        String iconUuid = "";
        Map<String, String> uploadFileToTemp = contentStorage.uploadTempFile(file, "component.iconUploadPath");
        if (MapUtils.isNotEmpty(uploadFileToTemp))
        {
            //            body.setMessage(uploadFileToTemp);
            head.setFlag(true);
            String iconPath = uploadFileToTemp.get(ComponentConstant.SOURCE_KEY);
            try
            {
                iconUuid = nasCSImageServiceImpl.addImage(iconPath);
                if (StringUtils.isNotBlank(iconUuid))
                {
                    uploadFileToTemp.put("uuid", iconUuid);
                    body.setMessage(uploadFileToTemp);
                }
            }
            catch (CSException e)
            {
                CodeCCUtils.errorLog(LOG, "nasCSImageServiceImpl  addImage failure", e);
                body.setMessage("nasCSImageServiceImpl  addImage failure");
            }
        }
        else
        {
            head.setErrorcode(ComponentErrorCodeConstant.UPLOAD_ICON_FAILED);
        }

        return msg;
    }

    public static byte[] readInputStream(InputStream inStream)
        throws Exception
    {
        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
        byte[] buffer = new byte[2048];
        int len = 0;
        while ((len = inStream.read(buffer)) != -1)
        {
            outStream.write(buffer, 0, len);
        }
        inStream.close();
        return outStream.toByteArray();
    }

    /**
     * base64上传图片
     */
    @RequestMapping(value = "/uploadBase64", method = RequestMethod.POST) @ResponseBody public BaseResponseMsg uploadMarkDownIcon(
        @RequestBody Map<String, String> base64Data, HttpServletRequest request, HttpServletResponse response)
    {
        BaseResponseBody body = new BaseResponseBody();
        ResponseHead head = new ResponseHead();
        BaseResponseMsg msg = new BaseResponseMsg(head, body);
        LOG.debug("上传文件的数据：" + base64Data);
        String dataPrix = "";
        String data = "";
        String iconUuid = "";
        LOG.debug("对数据进行判断");
        if (base64Data.isEmpty())
        {
            head.setErrorcode("上传失败，上传图片数据为空");
            return msg;
        }
        else
        {
            String[] d = base64Data.get("base64").split("base64,");
            if (d != null && d.length == 2)
            {
                dataPrix = d[0];
                data = d[1];
            }
            else
            {
                head.setErrorcode("上传失败，数据不合法");
                return msg;
            }
        }
        LOG.debug("对数据进行解析，获取文件名和流数据");
        String suffix = "";
        if ("data:image/jpeg;".equalsIgnoreCase(dataPrix))
        {//data:image/jpeg;base64,base64编码的jpeg图片数据
            suffix = ".jpg";
        }
        else if ("data:image/x-icon;".equalsIgnoreCase(dataPrix))
        {//data:image/x-icon;base64,base64编码的icon图片数据
            suffix = ".ico";
        }
        else if ("data:image/gif;".equalsIgnoreCase(dataPrix))
        {//data:image/gif;base64,base64编码的gif图片数据
            suffix = ".gif";
        }
        else if ("data:image/png;".equalsIgnoreCase(dataPrix))
        {//data:image/png;base64,base64编码的png图片数据
            suffix = ".png";
        }
        else
        {
            head.setErrorcode("上传图片格式不合法");
            return msg;
        }
        byte[] bytes = Base64.decodeBase64(data);
        String tempFileName = UUIDUtils.getUUIDStr() + suffix;
        LOG.debug("生成文件名为：" + tempFileName);
        Map<String, String> map = new HashMap<String, String>();
        map.put("fileName", tempFileName);
        try
        {
            //使用apache提供的工具类操作流
            FileUtils.writeByteArrayToFile(new File(SysConfigUtil.getStringValue("component.iconUploadPath",
                "/download/s01/upload/component/icon/"), tempFileName), bytes);
        }
        catch (Exception e)
        {
            CodeCCUtils.errorLog(LOG, "上传失败，写入文件失败", e);
        }
        File filePath =
            new File(SysConfigUtil.getStringValue("component.iconUploadPath", "/download/s01/upload/component/icon/"));
        if (!filePath.exists())
        {
            boolean mkdirs = filePath.mkdirs();
            if (!mkdirs)
            {
                head.setErrorcode("创建临时文件夹失败");
                return msg;
            }
        }
        try
        {
            //使用apache提供的工具类操作流
            FileUtils.writeByteArrayToFile(new File(filePath, tempFileName), bytes);
        }
        catch (Exception e)
        {
            CodeCCUtils.errorLog(LOG, "上传失败，写入文件失败", e);
        }
        try
        {
            iconUuid = nasCSImageServiceImpl.addImage("/download/s01/upload/component/icon/" + tempFileName);
            Map<String, String> imageInfo = nasCSImageServiceImpl.getImageInfo(iconUuid);

        }
        catch (CSException e)
        {
            CodeCCUtils.errorLog(LOG, "nasCSImageServiceImpl addImage failure", e);
        }
        if (StringUtils.isNotBlank(iconUuid))
        {
            head.setFlag(true);
            map.put("url", iconUuid);
            body.setMessage(map);

            return msg;
        }
        return msg;

    }

    /**
     * 删除图片文件
     * @param request map
     * @return BaseResponseMsg
     */
    @PostMapping("/delete/icon") @ResponseBody public BaseResponseMsg deleteIcon(HttpServletRequest request,
        String uuid)
    {
        BaseResponseBody body = new BaseResponseBody();
        ResponseHead head = new ResponseHead();
        BaseResponseMsg msg = new BaseResponseMsg(head, body);
        if (StringUtils.isBlank(uuid))
        {
            head.setErrorcode(ComponentErrorCodeConstant.UUID_IS_NULL);
            return msg;
        }
        boolean delImage = nasCSImageServiceImpl.delImage(uuid);
        head.setFlag(delImage);
        return msg;
    }

    //    /**
    //     * 上传图片到正式目录
    //     * <功能详细描述>
    //     * @param map
    //     * @return
    //     * @see [类、类#方法、类#成员]
    //     */
    //    @PostMapping("/upload/official/icon")
    //    @ResponseBody
    //    public BaseResponseMsg uploadOfficialIcon(HttpServletRequest request, @RequestBody Map<String, String> map)
    //    {
    //        BaseResponseBody body = new BaseResponseBody();
    //        ResponseHead head = new ResponseHead();
    //        BaseResponseMsg msg = new BaseResponseMsg(head, body);
    //        Map<String, Object> contentMap = new HashMap<String, Object>();
    //        if (MapUtils.isEmpty(map))
    //        {
    //            body.setMessage(ComponentErrorCodeConstant.FILE_IS_NULL);
    //            return msg;
    //        }
    //        String iconPath = map.get(ComponentConstant.SOURCE_KEY);
    //        String iconUuid = "";
    //        try
    //        {
    //            iconUuid = nasCSImageServiceImpl.addImage(iconPath);
    //            if (StringUtils.isNotBlank(iconUuid))
    //            {
    //                body.setMessage(iconUuid);
    //            }
    //        }
    //        catch (CSException e)
    //        {
    //            CodeCCUtils.errorLog(LOG, "nasCSImageServiceImpl  addImage failure", e);
    //            body.setMessage("nasCSImageServiceImpl  addImage failure");
    //        }
    //        return msg;
    //    }

    /**
     * 上传单个或多个临时文件
     * @param file
     * @return
     * @throws Exception
     */
    @RequestMapping(value = "/tempAttachments", consumes = "multipart/form-data", produces = "application/json", method = RequestMethod.POST) public BaseResponseMsg uploadTempAttachments(
        HttpServletRequest request, @RequestParam MultipartFile[] file)
    {
        BaseResponseBody body = new BaseResponseBody();
        ResponseHead head = new ResponseHead();
        BaseResponseMsg msg = new BaseResponseMsg(head, body);
        Set<String> set = new HashSet<String>();
        List<Map<String, String>> list = new ArrayList<Map<String, String>>();
        if (null == file || file.length <= 0)
        {
            head.setErrorcode(ComponentErrorCodeConstant.FILE_IS_NULL);
            return msg;
        }
        String stringValue = SysConfigUtil.getStringValue("dfx.component.attachments.quantity", "10");
        int parseInt = Integer.parseInt(stringValue);
        if (file.length > parseInt)
        {
            head.setErrorcode(ComponentErrorCodeConstant.ATTACHMENT_OVER_QUANTITY);
            return msg;
        }
        //校验文件大小
        Long size = (long)0;
        Long eachSize = (long)524288000;
        //校验重名
        for (MultipartFile multipartFile : file)
        {
            set.add(multipartFile.getOriginalFilename());
            size += multipartFile.getSize();
            if (multipartFile.getSize() > eachSize)
            {
                head.setErrorcode(ComponentErrorCodeConstant.EACH_ATTACHMENT_OVERSIZE);
                return msg;
            }
        }
        if (set.size() < file.length)
        {
            head.setErrorcode(ComponentErrorCodeConstant.ATTACHMENT_DUPLICATE);
            return msg;
        }
        long maxSize = (long)2147483647;
        if (size > maxSize)
        {
            head.setErrorcode(ComponentErrorCodeConstant.ATTACHMENT_OVERSIZE);
            return msg;
        }
        try
        {
            for (MultipartFile multipartFile : file)
            {
                Map<String, String> uploadFileToTemp = contentStorage.uploadTempFile(multipartFile, "component.attachmentUploadPath");
                if (MapUtils.isNotEmpty(uploadFileToTemp))
                {
                    list.add(uploadFileToTemp);
                }
            }
        }
        catch (Exception e)
        {
            CodeCCUtils.errorLog(LOG, "contentStorage.uploadTempFile(multipartFile) throw a ServiceException", e);
        }
        if (CollectionUtils.isNotEmpty(list))
        {
            body.setMessage(list);
            head.setFlag(true);
        }
        CodeCCUtils.debugLog(LOG, JSONUtil.listToString(list), null);
        return msg;
    }

    //    /**
    //     * 上传多个文件到正式目录
    //     * <功能详细描述>
    //     * @param map
    //     * @return
    //     * @see [类、类#方法、类#成员]
    //     */
    //    @PostMapping("/upload/official/attachments")
    //    @ResponseBody
    //    public BaseResponseMsg uploadOfficialAttachments(HttpServletRequest request,
    //        @RequestBody List<Map<String, String>> list)
    //    {
    //        BaseResponseBody body = new BaseResponseBody();
    //        ResponseHead head = new ResponseHead();
    //        BaseResponseMsg msg = new BaseResponseMsg(head, body);
    //        Map<String, Object> contentMap = null;
    //        if (org.apache.commons.collections4.CollectionUtils.isEmpty(list))
    //        {
    //            head.setErrorcode(ComponentErrorCodeConstant.FILE_IS_NULL);
    //            return msg;
    //        }
    //        //单个上传
    //        for (Map<String, String> map : list)
    //        {
    //            contentMap = new HashMap<String, Object>();
    //            contentMap.put(ComponentConstant.FILE_NAME, map.get(ComponentConstant.FILE_NAME));
    //            contentMap.put(ComponentConstant.SOURCE_KEY, map.get(ComponentConstant.SOURCE_KEY));
    //            //附件上传用2开头的partNo
    //            contentMap.put(ComponentConstant.PART_NO, PartNoUtil.getPartNo(PartNoType.ATTACHMENT));
    //            contentMap.put(ComponentConstant.FILE_SOURCE, "0");
    //            contentMap.put(ComponentConstant.NODE_ID, map.get(ComponentConstant.VERSIONID));
    //            try
    //            {
    //                boolean addContentByCopy =
    //                    ContentStorageImpl.addContentByCopy(ComponentConstant.CONTENTTYPE, contentMap);
    //                if (!addContentByCopy)
    //                {
    //                    //上传失败则删除所有的附件并返回失败
    //                    for (Map<String, String> map2 : list)
    //                    {
    //                        try
    //                        {
    //                            contentStorageService.delcontentinfo(map2.get(ComponentConstant.VERSIONID),
    //                                map2.get(ComponentConstant.PART_NO));
    //                        }
    //                        catch (ServiceException e)
    //                        {
    //                            CodeCCUtils.errorLog(LOG, "contentStorageService  delcontentinfo failure", e);
    //                            body.setMessage("contentStorageService  delcontentinfo failure");
    //                            return msg;
    //                        }
    //                    }
    //                    head.setFlag(false);
    //                    return msg;
    //                }
    //            }
    //            catch (CSException e)
    //            {
    //                CodeCCUtils.errorLog(LOG, "contentStorageService  delcontentinfo failure", e);
    //                body.setMessage("contentStorageService  delcontentinfo failure");
    //            }
    //
    //        }
    //        head.setFlag(true);
    //        return msg;
    //
    //    }
    //

    /**
     * 打包上传
     * @param componentName  versionId list
     * @return boolean
     */
    public boolean zipUploadComponent(String componentName, String versionId, List<Map<String, String>> list)
    {
        if (StringUtils.isEmpty(componentName) || org.apache.commons.collections4.CollectionUtils.isEmpty(list)
            || StringUtils.isEmpty(versionId))
        {
            return false;
        }
        String zipPath = File.separator + "download" + File.separator + "s01" + File.separator + componentName + ".zip";
        String fileName = componentName + ".zip";
        List<String> Paths = new ArrayList<String>();
        Map<String, Object> contentMap = new HashMap<String, Object>();
        List<String> nameList = new ArrayList<String>();
        for (Map<String, String> map : list)
        {
            Paths.add(map.get(ComponentConstant.SOURCE_KEY));
            nameList.add(map.get(ComponentConstant.FILE_NAME));
        }
        //        ZipUtil.compressedComponentZip(Paths, zipPath,nameList);
        contentMap.put(ComponentConstant.FILE_NAME, fileName);
        contentMap.put(ComponentConstant.SOURCE_KEY, zipPath);

        contentMap.put(ComponentConstant.PART_NO, PartNoUtil.getPartNo(PartNoType.FULL_DOWNLOAD));
        contentMap.put(ComponentConstant.FILE_SOURCE, "0");
        contentMap.put(ComponentConstant.NODE_ID, versionId);
        try
        {
            boolean addContentByCopy = ContentStorageImpl.addContentByCopy(ComponentConstant.CONTENTTYPE, contentMap);
            return addContentByCopy;
        }
        catch (CSException e)
        {
            CodeCCUtils.errorLog(LOG, "contentStorageService  delcontentinfo failure", e);
        }

        return false;

    }

    /**
     * 删除附件
     * @param request map
     * @return BaseResponseMsg
     * @throws Exception
     */
    @PostMapping("/delete/attachment") @ResponseBody public BaseResponseMsg deleteAttachment(HttpServletRequest request,
        Map<String, String> map)
        throws Exception
    {
        BaseResponseBody body = new BaseResponseBody();
        ResponseHead head = new ResponseHead();
        BaseResponseMsg msg = new BaseResponseMsg(head, body);
        if (MapUtils.isEmpty(map))
        {
            head.setErrorcode(ComponentErrorCodeConstant.FILE_IS_NULL);
            return msg;
        }
        try
        {
            contentStorageService.delcontentinfo(map.get(ComponentConstant.COMPONENTID),
                map.get(ComponentConstant.PART_NO));
        }
        catch (ServiceException e)
        {
            CodeCCUtils.errorLog(LOG, "contentStorageService  delcontentinfo failure", e);
            body.setMessage("contentStorageService  delcontentinfo failure");
            return msg;
        }
        head.setFlag(true);
        return msg;
    }

    @PostMapping(value = "/default/icon", produces = MediaType.APPLICATION_JSON) public BaseResponseMsg uploadDefaultIcon(
        @RequestBody Map<String, String> params)
        throws ExcelException, Exception
    {
        BaseResponseBody body = new BaseResponseBody();
        ResponseHead head = new ResponseHead();
        BaseResponseMsg msg = new BaseResponseMsg(head, body);
        String rootPath = SysConfigUtil.getStringValue("dfx.component.icon.root.path",
            "/tctHome/tomcat_8082/webapps/component/static/img/");
        String iconPath = "";
        if (null != params)
        {
            String iconName = params.get("imageName");
            if (StringUtils.isNotBlank(iconName))
            {
                iconPath = rootPath + iconName;
            }
        }
        if (StringUtils.isBlank(iconPath))
        {
            LOG.error("upload defult icon error,icon name is null.");
            head.setErrorcode(ComponentErrorCodeConstant.ICON_NAME_NULL);
            return msg;
        }

        try
        {
            // 上传组件图标
            String iconUuid = nasCSImageServiceImpl.addImage(iconPath);
            // 返回的uuid为空
            if (StringUtils.isBlank(iconUuid))
            {
                head.setErrorcode(ComponentErrorCodeConstant.ICON_UUID_NULL);
                return msg;
            }

            head.setFlag(true);
            body.setMessage(iconUuid);
        }
        catch (CSException e)
        {
            CodeCCUtils.errorLog(LOG, "nasCSImageServiceImpl.addImage(iconpath) throw a CSException", e);
            head.setErrorcode(ComponentErrorCodeConstant.ICON_UPLOAD_FAILED);
            return msg;
        }

        return msg;
    }
}


